let age : number  = 25;

// let age  = 25;



/* 
 * function (a,b){
 * retun a + b;
 * }
 */


console.log(age);
console.log(add(1,2));


let count : number  = 10;


let message : string = 'Hello, typescript!';

function greet (name: string) : void {
	console.log(`Hello, ${name}`);
};

function add(a: number, b: number): number{
  return a + b;
};


// aca solo trabajamos de la siguiente manera 

/* 
 * las variables que se trabajan son 
 *
 * let  --- variable de cambio 
 * const -- variable de un solo uso
 *
 */

// podemos declarar varias variables de la siguiente forma

let x: number, y: number, z: number; 

// anotaciones opcionales que se le puede asignar a la variable 

let age : number | undefined;
age = 30; // esto es valido
age  = undefined; // esto tambien es valido

// si queremos inducir datos de manera opcional lo podemos hacer la siguiente manera

interface Person {
	name: string; 
	age?: number; // esta es la propiedad opcional
}


function createPerson (name: string, age?:number): Person { 
	const person : Person = {name};
	if (age !== undefined) {
		person.age = age;
	}
	return person;
}
// ahora trabajando con el tipo ANY --> acepta cualquier valor : 'confia en mi, yo me encargo'

let data : any;
data = 32;
data = 'hello';
data = true;


// Tenemos los datos primitivos en Typescript 

// NUMBER 

let integer : number = 42;
let floating : number = 3.14;
let negative : number = -10;

let binary : number = 0b1010;
let octal : number = 0o12;
let hexadecimal : number = 0xA;


// STRING 

let cSimple : string  = 'hello';
let cDoble : string = "hello";
let bacticks : string = `hello`;
let bacticksV : string = `hello ${name}`;

// BOOLEAN

let isActive : boolean = true;
let hasError : boolean = true;
let isGreater : boolean = 10>5;


// NULL / UNDEFINED

let emptyVar : null = null;
let unIVar : undefined = undefined;
let optionalVar : string | null =  null;

// Operadores Aritmeticos 

let n1 = 10;
let n2 = 5;

console.log(a + b);
console.log(a - b);
console.log(a * b);
console.log(a / b);
console.log(a % b);


// Operadores de comparacion

console.log(a  == b);
console.log(a  != b);
console.log(a  === b);
console.log(a  !== b);
console.log(a  > b);
console.log(a  < b);
console.log(a  >= b);
console.log(a  <= b);


// Operadores Logicos

console.log(a && b);
console.log(a || b);
console.log(!a);


// Operadores de asignacion


a += b; // a = a + b => a = 15
a -= b; // a = a - b => a = 10
a *= b; // a = a * b => a = 50 
a /= b; // a = a / b => a = 10
a %= b; // a = a % b => a = 0


// Flujos de control 

// if - else

let age = 18;

if(age >= 18){
	console.log('you are an adult');
}else{
	console.log('you are not an adult');
}

// if - else -if else

let score = 85;

if(score >= 90){
	console.log('Grade A');
}else if(score >= 80){
	console.log('Grade B');
}else if(score >= 70){
	console.log('Grade C');
}else if(score >= 60){
	console.log('Grade D');
}

// SWITCH 

let dayOfWeek  = 3;
let dayName : string;

switch(dayOfWeek){
	case 1: 
		dayName = "Monday";
		break;

	case 1: 
		dayName = "Monday";
		break;
	case 2: 
		dayName = "Tuesday";
		break;
	case 3: 
		dayName = "Wednesday";
		break;
	case 4: 
		dayName = "Thursday";
		break;
	case 5: 
		dayName = "Friday";
		break;
	case 6: 
		dayName = "Saturday";
		break;
	case 7: 
		dayName = "Sunday";
		break;
}

console.log(dayName);



// FOR 

for (let i = 0; i < 5; i++){
	console.log(i);
}

// WHILE 

while(i < 5){
	console.log(i);
	i++;
}

// FOR OF 

let names = ['alice', 'bob', 'charlie'];
for (let name of names){
	console.log(name);
}

// FOR IN 

let per = {
	firstName : 'Alice',
	lastName : 'Smith'
}

for (let key in person) {
	console.log(`${key} : ${person[key]}`);
}


// DEFINICION DE UNA FUNCION

function great(name : string) : string { 
	return `Hello ${name}`;
}

let greating = great('ramon');
console.log(greating);

// reduciendo la funcion a una funcion flecha 

const geat = (name : string) : string =>{
	return `Hello ${name}`;
}
console.log(geat);


// Funcion Parametros 

function add ( a: number, b:number){
	return a + b;
}

let sum = add(10,20);

// funcion con parametros opcionales

function multiply( a:number, b: number = 1): number {
	return a * b;
}
console.log(multiply(5));

console.log(multiply(5,2));

// concatenando parametros

function concate(a: string, b?: string): string{
	return b ? `${b}` : a;
}

console.log(concate('hello'))
console.log(concate('hello', 'world'))


// Retorno de tipos 

function isEven(number : number): boolean { 
	return number % 2 === 0;
} 

console.log(isEven(4));
console.log(isEven(5));


// Funcion de primera clase en Typescript

// Funciones como variables

const sayHello = (name : string) => `Hello ${name}`;
// 
// Funciones como argumentos

function gray(fn(name:string) => string, name: string){ console.log(fn(name));}

// funciones como retorno de valores 

function multiplier(factor : number) : (num : number) => number {
	return (num) => num * factor;
}

const double = multiplier(2);
console.log(double(3));

// definiciones de los tipos de funciones


let convert : (inpt: string) => number;
convert = (s) => parseInt(s, 10); // el 10 es el tipo de base en el que se cambia -- decimal
convert = (s) => parseInt(s, 2); // el 2 es el tipo de base en el que se cambia  -- binario
convert = (s) => parseInt(s, 255); // el 10 es el tipo de base en el que se cambia -- hexadecimal
convert = (s) => parseInt(s, 8); // el 10 es el tipo de base en el que se cambia -- octal
console.log(convert("5"));

// ARRAYS Y TUPLAS 

let numbers : number [] = [1,2,3,4,5];

//la forma de declarar un array es de esta forma

let numebrs: Array<number> = [1,2,3,4,5];

// Si nosotros queremos que los valores sean inmutables hacemos lo siguiente 

let readOnlyNumbers : ReadonlyArray<number> = [1,2,3,4,5];

// TUPLAS 

let person : [string, number]  = ['alice', 10];

// haciendo una variable opcional 

let person : [string, number?] = ['alice'];

// indicando el valor de una variable 

let labeledP : [name : string, age:number] = ['alice', 30];


// ENUMS --> sirve mas para determinar apartados que ya tengan valores


enum Color {
	Red, 
	Green, 
	Blue, 
}

// Asignando valores

enum Color {
	Red = 1, 
	Green = 2, 
	Blue = 3, 
}



let backgroundColor: Color = Color.Blue;
if(backgroundColor === Color.Blue){
}


// puedes usar para mencionar miembros

enum UserRola {
	Admin = 'ADMIN',
	Editor = 'EDITOR',
	Viewer = 'VIEWER',
}


// INTERFACES
	
// -- se recomienda mas hacer uso en Obj
// -- hacer el uso de Prefijos para interfaces genericas

interface Pers {
	name : string;
	age : number;
	greet() : void ;
}

let person1 : Person  = {
	name : 'Alice',
	age : 30,
	greet() {
		console.log(`Hello ${this.name}`);
	}
};


// para asignar valores opcionales en Interfaces hacemos lo siguiente 

interface Data { 
	name : string;
	age : number;
	email?: string;
	greet() : void;
	sayGoodBye?(): void;
}

let person1 : Data  = {
	name : 'Alice',
	age : 30,
	greet() {
		console.log(`Hello ${this.name}`);
	}
};


// EXTENDS : trabajando con extension con interfaces

interface Datos {
	name : string;
	age : number;
	greet(): void;
}

interface Employee extends Datos {
	employeeId: number;
	department: string;
	clockIn(): void;
}


let employee : Employee = {
	name : 'alice',
	age : 30,
	employeeId : 1234,
	departament : 'sales',
	greet(){
		console.log('Hello ,' + this.name);
	},
	clockIn(){
		console.log(this.name + ' clocked in ');
	}
};

// CLASES

class Car { 
	brand : string;
	model : string;
	year : number ; 
}

let myCar = new Car();
myCar.brand = 'Toyota';
myCar.model = 'Corolla';
myCar.year = 2010;


// uan forma de recibir valores de forma mas rapida es de la siguiente manera 

class Carro{
	brand: string;
	model: string;
	year: number; 
	constructor ( brand: string, model : string, year: number){
		this.brand = brand;
		this.model = model;
		this.year = year;
	}
}


let miCarro = new Carro('Toyota','Corolla','2010');

// para simplificarlo podemos hacerlo de la siguiente manera 


class Caro { 
	constructor (
		public brand: string;
		public model: string;
		public year: number;
	){}
}


// Trabajando las herencias en las clases 


class Vehicle { 
	speed: number;
	constructor(speed : number){
		this.speed = speed;
	}
	move(){
		console.log(`The vehicle is moving at ${this.speed} miles poer hour`);
	}
}

class Carrr extends Vehicle{
	wheels: number;
	constructor(speed: number, wheels: number){
		super(speed); // recuerda que tenemos que usar la herencia para usar la herencia 
		this.wheels = wheels;
	}
	honk(){
		console.log('beep beep');
	}
}


// ABSTRACT CLASS -- trabajando con clases abstractas

// -- conlleva mas a PO
// -- compartir codigo comun entre clases relacionadas 
// -- propiedades con valores 
// -- controlar acceso con modificadores (public, protected, private)
// -- forzar estructura comun pero con implementacion parcial 
// -- usar constructores para inciializacion comun 



abstract class Shape{
	abstract getArea(): number;
}
class Circle extends Shape{
	constructor (public radius: number){
		super();
	}
	getArea(): number{
		return Math.PI * this.radius ** 2;
	}
}


// ENCAPSULAMIENTO : PRIVATE / PUBLIC / PROTECTED

// trabajo con Public 

class Circulo{
	radius: number;
	constructor(radius: number){
		this.radius = radius;
	}
	getArea(): number{
		return Math.PI * this.radius ** 2;
	}
}

const MyCircle = new Circulo(3);
console.log(MyCircle.radius);
console.log(MyCircle.getArea());


// ahora se esta trabajara con el 
// PRIVATE 

class cube{
	private radius : number;
	constructor(radius : number){
		this.radius = radius;
	}

	getArea() : number{
		return Math.PI * this.radius ** 2;
	}

	getRadius(): number{
		return this.radius;
	}
}

const myCube = new Cube(3);

// esto me generara un error ya que no puede acceder a una propiedad privada
console.log(myCircle.radius);

console.log(myCube.getArea());

console.log(myCube.getRadius());


// ahora se esta trabajando con 
// PROTECTED

class Shape {
	protected area: number;
	constructor(area : number){
		this.area = area;
	}
}

class Circle extends Shape {
	radius : number;
	constructor(radius: number){
		super(Math.PI * radius ** 2);
		this.radius = radius;
	}
	getArea() : number { 
		return this.area;
	}
}


// COMPATIBILIDAD DE TIPOS Y COERCION DE TIPOS DE TYPESCRIPT

interface Named{
	name : string;
}

let x : Named;
let y = {name : "Alice", location : "Seattle"};
x = y;


interface Named{
	name: string;
}

class Person {
	name: string;
}

let p: Named;
p = new Person();


// compatabilidad de tipos 

interface Perro {
	nombre : string;
	ladrar(): void;
	
}

interface Mascota {
	nombre : string;
	ladrar(): void;

}


let perro: Perro = {nombre: 'Rex', ladrar: () => console.log("gua")};
let mascota: Mascota = perro;


// Typescript con mas propiedades a un tipo con menos

interface Punto2D{
	x:number;
	y:number;

}

let punto3D = {x:1, y:2, z : 3};
let punto2D: punto2D = punto3D;


//Coercion de tipos 
//lo cambia los valores automaticamente a otro tipo 

let resultado = '5' + 3;
let resta = '5' - 3;

let num: number = '5';

// Afirmaciones de tipos
// no se convierten el valor, solo cambian como TYPESCRIPT lo trata

let valor: unknow = 'hola mundo';

let longitud2  = (<string>valor).length;

let input = document.getElementById("email") as HTMLInputElement;
input.value = 'test@ejemplo.com';

// Importante : las afirmaciones no cambian el valor un runtime, solo afectan la verificacion de tipos:

let numero: any = '123';
let valor = numero as number;

valor.toFixed(2);

// Covarianza y Contravarianza

// Covarianza

class Animal {
	nombre : string = ' ';
}

class Perro extends Animal{
	ladrar(){}
}

class Gato extends Animal{
	maullar(){}
}

// Covarianza en retornos

type FuncionAnimal = () => Animal;
type FuncionPerro = () => Perro;


let funcionPerro: FuncionPerro = () => new Perro();
// Retorna un perro es seguro cuando se espera un Animal
let funcionAnimal: FuncionAnimal = funcionPerro; // Covariante


// CONTRAVARIANZA

type ManejandoPerro = (perro: Perro) => void;
type ManejandoAnimal = (animal: Animal) => void;

let manejarAnimal: ManejandoAnimal (animal) => {
	console.log(animal.nombre);
}

// Una funcion que maneja cualquier Animal puede manejar Perros
let manejarPerro: ManejandoPerro = manejarAnimal; // Contravariante


// Un ejemplo practico de CONTRAVARIANZA

class Vehiculo { 
	arrancar{}
}

class Coche extends Vehiculo{
	tocarBocina(){}
}

// Esto es seguro (cocarianza en retornos)
let obtenerVehiculo: () => Vehiculo;
let obtenerCoche: () => Coche = () => new Coche();

obtenerVehiculo = obtenerCoche; // Un coche es un Vehiculo

// esto es SEGURO (contravarianza en prametros)

let usarCoche: (c: Coche) => void;
let usarVehiculo: (v: Vehiculo) => void = (v) => v.arrancar();
usarCoche = usarVehiculo; // puede usar cualquier vehiculo


// Readonly y Partial Types

interface Usuario{
	id: number;
	nombre: string;
	email: string;
}

let usuario: Readonly<Usuario> = {
	id: 1,
	nombre: Ana,
	email: 'ana@example.com'
};

usuario.nombre = 'Maria'; // error: no se puede modificar

//Tambien existe readonly para propiedades individuales

interface Config{
	readonly apyKey: string;
	timeout: number;
}



// Arrays readonly

let numeros: readonly number[] = [1,2,3];

numeros.push(4); // Error: push no existe en readonly array
numeros[0] = 10; // Error: no se puede modificar

// ReadonlyArray<T> es equivalente

let lista: ReadonlyArray<string> = ['a', 'b'];

// PARTIAL <T>

interface Producto { 
	id: number;
	nombre: string;
	precio: number;
	descripcion: string;

}

// Util para actualizaciones parciales

function actualizarProducto(
	id: number,
	cambios: Partial<Producto>
):void{
	// Puedes pasar solo las propiedades que quieres cambiar
}

actualizarProducto(1, {precio: 29.99}); // solo actualiza precio
actualizarProducto(2, {nombre: 'Nuevo', descripcion: '...'});


// COMBINANDO UTILITY TYPES

interface Configuracion{
	host: string;
	puerto: number;
	debug: boolean;
}

// Inmutable y con propiedades opcionales

type ConfigParcialInmutable = Readonly<Partial<Configuracion>>;

let config: ConfigParcialInmutable = {host: 'localhost'};
config.puerto = 3000; // Error : readonly


// OTROS UTILITY TYPES UTILES

// Required : hace toas las propiedades obligatorias

type ProductoComplete = Required<Partial<Producto>>;

// Pick: selecciona propiedades especificas

type ProductoResumen = Pick<Producto, 'id' | 'nombre'>;

// Omit: excluye propiedades especificas

type ProductoSinId = Omit<Producto, 'id'>;

// Record: crea un objeto con claves y valores de tipos especificos

type ProductoPorCategoria = Record<String, Producto[]>;

// READONLY TYPES

interface Person{
	name: string;
	age : number;
}

// type ReadonlyPerson = Readonly<Person>

let john: ReadonlyPerson = {name: 'John', age:25};
john.age = 26;

let numbers: number[] = [1,2,3,4,5];
numbers[0] = 0;

let numbers: ReadonlyArray<number> = [1,2,3,4,5];
numbers[0] = 6; // este si permite leer el siguiente dato
numbers.push(6); // tienes que tener en cuneta que los datos que se ingresan en readonly no son mutables 


const person = {
	name : 'John',
	details : {
		age : 25,
		address : '123 Stret',
	}
} as const;

person.name = 'Doe';
person.details.age = 26;

// Tipos parciales

interface Employee{
	id: number;
	name : string;
	department: string;
}

fucntion createEmployee(employee: Partial<Employee>){
}

createEmployee({ id: 1, name: 'John'});
createEmployee({ id: 2, name: 'HR'});
createEmployee({ id: 3, name: 'Engineering'});


// Type aliases

type Point = {
	x: number;
	y: number;
};

let p: Point = {x:10, y:20};

type User = {
	name: string;
	email: string;
};

type UserPromise = Promise<User[]>;

let getUsers: UserPromise;


// Uniones e intersecciones Types 

// Tipos de Uniones

type StringOrNumber = string | number;
let variable: StringOrNumber;
variable = "Hello";
variable = 42;
variable = true;


// INTERSECCION DE TIPOS

type HasName = {name: string};
type HasAge = {age: number};
type Person = HasName & HasAge;
let person: Person = {
	name: 'Alice',
	age: 30,
};

let invalidPerson: Person{
	name: 'Bod'
}; // esta mal porque se require una tipo person


// Guardas de tipo y predicados de tipo 
// Ayuda a reducir la cantidad de busqueda de una variable y devulven como valor un booleano

function doSomething(value: string | number){
	if(typeof value === 'string'){
		console.log(value.toUpperCase());
	}else{
		console.log(value.toFixed(2));
	}
}

// entonces este seria el siguiente ejemplo 

function isString(value:any):value is string {
	return typeof value === 'string';
}

function doSomething(value: string | number){
	if(isString(value)){
		console.log(value.toUpperCase());
	}else{
		console.log(toFixed(2));
	}
}

// trabajando con Funciones Avanzadas

// Advanced type system concepts
// working with generics in Typescript 
// Using decorators to simplify your code 
// manipulacion de tipos con mapped y tipos condicionales
// tipos de tecnicas de interfaces avanzadas 


let value: number | string = Math.random() > 0.6 ? 'Hello ' : 123;

if (typeof value === 'string'){
	console.log(value.toUpperCase());
}else{
	console.log(value.toFixed(2));
}


/// AHORA TRABAJANDO CON INSTANCEOF

class Cat{
	meow(){
		console.log('Meow!');
	}
}

class Dog{
	bark(){
		console.log('Woof');
	}
}

let pet: Cat | Dog = Math.random() > 0.5 ? new Cat() : new Dog();

if (pet instanceof Cat ) {
	pet.meow();
}else{
	pet.bark();
}




































